///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the check namespace
open class Check {
    /// EchoArg contains the arguments to be sent to the Dropbox servers.
    open class EchoArg: CustomStringConvertible {
        /// The string that you'd like to be echoed back to you.
        public let query: String
        public init(query: String = "") {
            stringValidator()(query)
            self.query = query
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EchoArgSerializer().serialize(self)))"
        }
    }
    open class EchoArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EchoArg) -> JSON {
            let output = [ 
            "query": Serialization._StringSerializer.serialize(value.query),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EchoArg {
            switch json {
                case .dictionary(let dict):
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .str(""))
                    return EchoArg(query: query)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// EchoResult contains the result returned from the Dropbox servers.
    open class EchoResult: CustomStringConvertible {
        /// If everything worked correctly, this would be the same as query.
        public let result: String
        public init(result: String = "") {
            stringValidator()(result)
            self.result = result
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(EchoResultSerializer().serialize(self)))"
        }
    }
    open class EchoResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: EchoResult) -> JSON {
            let output = [ 
            "result": Serialization._StringSerializer.serialize(value.result),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> EchoResult {
            switch json {
                case .dictionary(let dict):
                    let result = Serialization._StringSerializer.deserialize(dict["result"] ?? .str(""))
                    return EchoResult(result: result)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }


    /// Stone Route Objects

    static let app = Route(
        name: "app",
        version: 1,
        namespace: "check",
        deprecated: false,
        argSerializer: Check.EchoArgSerializer(),
        responseSerializer: Check.EchoResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "app",
                "host": "api",
                "style": "rpc"]
    )
    static let user = Route(
        name: "user",
        version: 1,
        namespace: "check",
        deprecated: false,
        argSerializer: Check.EchoArgSerializer(),
        responseSerializer: Check.EchoResultSerializer(),
        errorSerializer: Serialization._VoidSerializer,
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
}
